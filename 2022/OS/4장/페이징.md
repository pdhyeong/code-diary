## 페이징(Paging)

일정한 크기의 블록을 페이지라고 하였다. 이처럼 주소 공간을 페이지 단위로 나누고,실제 주속 공간은 페이지 크기와 같은 페이지 프레임(Page frame)으로 나누어 사용할 수 있다.

세그먼테이션 기법과 혼합하여 사용하는 페이징 기법도 있지만 그것보단 순수한 페이징 기법에 대해서 설명할 것이다.

페이징 시스템에서의 가상주소는 순서쌍 v = (p,d)로 표현하고 p는 가상 메모리 내에서 참조될 항목이 속해있는 페이지 번호이고,

d는 페이지 내에서 참조될 항목이 위치하고 있는 곳의 변위이다.


만약 참조되어야하는 페이지가 주거익장치 내에 없다면 그 해당 페이지는  블록 단위로 보조기억장치로부터 주기억장치로 옮겨져서 페이지 프레임이라는 불리는 주기억장치의 한 블록에 자리잡게된다.

페이징 기법 하에서의 동적 주소 변환은 프로세스가 참조하는 가상 주소를 v = (p,d)라고 할 때,

페이징 사상 테이블(Paging mapping table)에서 페이지 p를찾고, 페이지가 p가 페이지 프래임 p'에 있음을 알아낸다. 그 후 p'와 d를 더해 주기억장치상의 실제 주소 r = p' + d를 구한다.

이과정에서 프로세스의 모든 페이지들이 도잇에 주기억장치 내에 존재할 수 없으므로, 페이지 사상 테이블은 참조된 페이지에 대한 주기억장치 내의 존재여부를 나타내야하며,

만약 존재한다면 그 위치를 , 존재하지 않으면 보조기억장치의 어느 곳에 위치하는 지를 알 수 있어야한다.

만약 해당 페이지가 주기억장치 내에 없음녀 페이지 사상 테이블에 페이지 존재 비트(page residence bit)는 0 으로 표시되고, 주기억장치내에 존재할 떄는 1로 표시 된다.


### 직접사상(direct mapping)

수행 중인 프로세스가 참조하는 가상 주소 v = (p,d)는 다음과 같이 실제 주소로 변환된다.

프로레스 수행 전 운영체제는 페이지 사상 테이블로 주기억장치 주소를 페이지 사상 테이블 시작점 레지스터(page map table origin register)에 넣는다. 

그 후 페이지 사상 테이블의 시작주소(base address) b를 페이지 번호 p에 더하여 페이지 p에 대한 항목이 위치하는 주기억장치 주소인 b + p 를 형성한다.

페이지 프레임 p'가 가상 페이지 p에 대응함을 나타내고, 이어 p'는 변위 d와 접속되어 실제 주소 r = p' + d를 읽는다.

 페이지 사상테이블에는 가상 메모리를 구성하는 모든 프로세스의 페이지에 대한 항목이 있기 때문에 직접 사상의 한 예가 된다고 할 수 있다.
 
 프로세스가 자신의 가상 메모리에 n개의 페이지를 가지고 있다면,
 
 프로세스에 대한 직접 사상 페이지 사상 테이블(direct mapped page map table )에는 페이지 0, 페이지 1, 페이지 2 ... 페이지 n에 대한 항목(entry)이 연속적으로 배열되어 있다.
 
 직접 사상 방법에서 아주 큰 페이지 사상 테이블은 보통 주기억장치에서 유지,관리 하게 된다. 또한 변환되는 가장 주소와 페이지 사상 테이블의 시작 주소는 제어장치 내의 고속 레지스터에 보관함으로써 페이지 사상 테이블의 참조는 한 주기억장치 주기 시간(cycle) 내에서 수행되어야 한다.
 
 이유는 주기억장치의 주기 시간이 명령 실행 주기(instruction execution cycle)의 대부분을 차지 하고 있고, 
 
 페이지 사상을 위해 또 다른 주기억장치 실행 주기를 요구하게 되기 떄문에 직적 사상에서의 페이지 주소 변환은 시스템에서의 프로그램 수행 시간을 지연시킬 수 있다.
 
 따라서 보다 빠른 주소 변환을 하여 빠른 고속 캐시기억장치(highspeed cache memory)를 이용하여 직접 사상의 페이지 사상 테이블을 구현 하고 있으므로 직접 사상이 전혀 효용성 없진 않다.
 
 
 ### 연관 사상(associative mapping)
 
 가상 메모리의 개념이 유용하기 위해서는 동적 주소 변환이 신속하게 수행되어야한다.
 
 보다 개선된 방법중 하나는 주기억장치보다 훨씬 빠른 접근 시간을 가지고 있는 연관기억장치에 페이지 사상 테이블 전체를 넣는 방법
 
 이 방법은 저장된 값을 이용하여 데이터를 접근(access)하는 내용 주소화 메모리(CAM: Content Addressable Memory)와 찾고자 하는 내용의 일부를 기억하는 데이터 레지스터가 운영된다.
 
 페이지 p 에 대응하는 프레임 p'를 찾아내어 변위 d를 더함르호써 실제주소 r = p' + d를 구한다.
 
 연관 사상 테이블(assoicative mapping talbe)로 향하는 포인터들이 실제로 사상 테이블의 모든 단위 항목으로 들어감에 유의한다.
 
 접근할 내뇽의 일부분이 존재하는 p와 일치하는 내용을 찾기 위하여 연관기억장치의 모든 단위 항목을 동시에 조사하며, 이겅ㅅ은 신속한 동적 주소 변환을 가능하게 한다.
 
 하지만 연관기억장치는 고가이기 때문에 페이지 사상 테이블 전체를 위한 연관 기억장치의 설치에는 비싼 대가를 지불한다. 그래서 저가의 직접 사상 방버과 고가의 연관사상 방법을 효율적으로 혼합한 형태로 사용한다.
 
 ### 연관 / 직접 사상
 
 캐시기억장치만을 사용한 순수한 직접 사상의 구현이나 연관기억장치만을 사용한 순수한 연관 사상의 구현은 주기억장치보다 비용이 너무 많이 들기 때문에,
 
 보다 적당한 비용으로 캐시나 연관기억장치 기법에 의한 장점을 살릴 수 있는 절충 방안이 등장했다.
 
 가장 최근에 참조된 페이지는 조만간 다시 사용되기 귑다는 사실을 이용하여 연관기억장치에는 페이지 사상 테이블의 전체 항목 중 가장 최근에 참조된 일부 페이지 항목들만을 수용하는 것이다.
 
 이때, 보다 좋은 성능을 위하여 부분적인 연관 페이지 사상 테이블이 반드시 커야 할 필요는 없다.
 
 이 부분적 수용 시스템들은 90% 이상의 성능을 가진다고 한다.
 
 동적 주소 변환은 다음과 같이 진행한다.
 
 페이지 p를 연ㅇ관 페이지 사상 테이블에서 찾는다. 이 테이블에서 가상 페이지 p에 대한 항목을 찾으면 p와 대응되는 페이지 프레임 번호 p'를 얻고 이를 변위 d에 접속하여 가상 주소 v = (p,d) 에 대한 실제주소 r = p' + d를 구한다.
 
 만약 p와 일치하는 항목이 연관 페이지 사상 테이블에 없으면 우선, 직접 페이지 사상 테이블의 주기억ㅈ아치 주소를 페이지 사상 테이블 시작점 레지스터에 넣는다. 그 후
 
 직접 페이지 사상 테이블의 시작주소 b를 페이지 변호 p에 더하여 p에 대한 항목의 주기억ㅈ아치 주소인 b + p를 형성한다. 이 주소에 해당 하는 항목을 찾아서 가상 페이지 p에 대응되는 페이지 프레임 p'를 얻고,
 
  이어 p'는 변위 d와 접속되어 가상 주소 v = (p,d)에 대한 실제주소 r = p' + d를 구한다.
  
  ### 페이징 시스템의 공유
  
  다중 프로그래밍이 가능한 컴퓨터 시스템, 특히 시분할 환경 하에서는 여러 사용자가 동일한 프로그램을 동시에 수행시키는 경우가 흔히 있다.
  
이는 기억장치의 낭비를 발생 시키는데, 해결책으로 공유가 가능한 페이지를 가능한 한 공유하도록 하는 것이다.

수정이 불가능한 프로시듀어를 순수 프로시듀어(pure procedure) 또는 재진입가능 프로시듀어(reentrant procedure) 라고 하는데

만약 이 코드가 재진입되면 이는 수행중 결코 변경되지 않기 때문에 공유가 가능하며 수정이 가눙한 데이터는 공유될 수 없다.

따라서 각 페이지의 공유가 가능한지 아닌지를 정의해 둘 필요가 있다는 것.

### 페이지 크기

페이지 시스템에 있어서 실제 기억 장치는 일반적으로 고정된 크기의 페이지 프레임으로 나누어지는데 이러한 페이지 프레임의 크기는 얼마로 할 것인가,

모든 페이지를 같은 크기로 할 것인가등 여러가지 의문이 생기는데 정해진 정답은 없다.

페이지의 크기를 결정함에 있어 고려할 요소는 다음과 같다.

 - 테이블 단편화 : 페이지 크기가 작으면 작을수록 보다 맣은 페이지와 페이지 프레임이 존재하게 되고 이를 관리하기 위한 페이지 테이블의 크기가 증가하여 기억 공간이 낭비된다.

이러한 기억장소의 낭비 현상을 테이블 단편화(table fragmentiation)라고 한다.

-작업세트 : 페이지 크기가 작을수록 프로세스가 작업세트(working set)를 확보하는 데 도움이 된다. 프로세스들은 구역성을 가지며, 이 구역 내에서는 비교적 소량의 정보만을 필요로 하기 때문이다.

- 실제로 프로시듀어나 데이터 블록의 단위는 대부분 페이지 크기의 정수 배가 아니므로 페이징 시스템은 단편화 현상을 초래하게 된다. 마지막 페이지가 보통 평균적으로 1/2 페이지의 단편화가 생기게된다.
따라서 페이지 크기가 작을 수록 내부의 단편화는 감소된다.
 
- 페이지가 크게되면 참조되지 
