## 페이징(Paging)

일정한 크기의 블록을 페이지라고 하였다. 이처럼 주소 공간을 페이지 단위로 나누고,실제 주속 공간은 페이지 크기와 같은 페이지 프레임(Page frame)으로 나누어 사용할 수 있다.

세그먼테이션 기법과 혼합하여 사용하는 페이징 기법도 있지만 그것보단 순수한 페이징 기법에 대해서 설명할 것이다.

페이징 시스템에서의 가상주소는 순서쌍 v = (p,d)로 표현하고 p는 가상 메모리 내에서 참조될 항목이 속해있는 페이지 번호이고,

d는 페이지 내에서 참조될 항목이 위치하고 있는 곳의 변위이다.


만약 참조되어야하는 페이지가 주거익장치 내에 없다면 그 해당 페이지는  블록 단위로 보조기억장치로부터 주기억장치로 옮겨져서 페이지 프레임이라는 불리는 주기억장치의 한 블록에 자리잡게된다.

페이징 기법 하에서의 동적 주소 변환은 프로세스가 참조하는 가상 주소를 v = (p,d)라고 할 때,

페이징 사상 테이블(Paging mapping table)에서 페이지 p를찾고, 페이지가 p가 페이지 프래임 p'에 있음을 알아낸다. 그 후 p'와 d를 더해 주기억장치상의 실제 주소 r = p' + d를 구한다.

이과정에서 프로세스의 모든 페이지들이 도잇에 주기억장치 내에 존재할 수 없으므로, 페이지 사상 테이블은 참조된 페이지에 대한 주기억장치 내의 존재여부를 나타내야하며,

만약 존재한다면 그 위치를 , 존재하지 않으면 보조기억장치의 어느 곳에 위치하는 지를 알 수 있어야한다.

만약 해당 페이지가 주기억장치 내에 없음녀 페이지 사상 테이블에 페이지 존재 비트(page residence bit)는 0 으로 표시되고, 주기억장치내에 존재할 떄는 1로 표시 된다.


------------------------------------------------------------


### 직접사상(direct mapping)

수행 중인 프로세스가 참조하는 가상 주소 v = (p,d)는 다음과 같이 실제 주소로 변환된다.

프로레스 수행 전 운영체제는 페이지 사상 테이블로 주기억장치 주소를 페이지 사상 테이블 시작점 레지스터(page map table origin register)에 넣는다. 

그 후 페이지 사상 테이블의 시작주소(base address) b를 페이지 번호 p에 더하여 페이지 p에 대한 항목이 위치하는 주기억장치 주소인 b + p 를 형성한다.

페이지 프레임 p'가 가상 페이지 p에 대응함을 나타내고, 이어 p'는 변위 d와 접속되어 실제 주소 r = p' + d를 읽는다.

 페이지 사상테이블에는 가상 메모리를 구성하는 모든 프로세스의 페이지에 대한 항목이 있기 때문에 직접 사상의 한 예가 된다고 할 수 있다.
 
 프로세스가 자신의 가상 메모리에 n개의 페이지를 가지고 있다면,
 
 프로세스에 대한 직접 사상 페이지 사상 테이블(direct mapped page map table )에는 페이지 0, 페이지 1, 페이지 2 ... 페이지 n에 대한 항목(entry)이 연속적으로 배열되어 있다.
 
 직접 사상 방법에서 아주 큰 페이지 사상 테이블은 보통 주기억장치에서 유지,관리 하게 된다. 또한 변환되는 가장 주소와 페이지 사상 테이블의 시작 주소는 제어장치 내의 고속 레지스터에 보관함으로써 페이지 사상 테이블의 참조는 한 주기억장치 주기 시간(cycle) 내에서 수행되어야 한다.
 
 이유는 주기억장치의 주기 시간이 명령 실행 주기(instruction execution cycle)의 대부분을 차지 하고 있고, 
 
 페이지 사상을 위해 또 다른 주기억장치 실행 주기를 요구하게 되기 떄문에 직적 사상에서의 페이지 주소 변환은 시스템에서의 프로그램 수행 시간을 지연시킬 수 있다.
 
 따라서 보다 빠른 주소 변환을 하여 빠른 고속 캐시기억장치(highspeed cache memory)를 이용하여 직접 사상의 페이지 사상 테이블을 구현 하고 있으므로 직접 사상이 전혀 효용성 없진 않다.
 
 
 ------------------------------------------------------------
 
 
 ### 연관 사상(associative mapping)
 
 가상 메모리의 개념이 유용하기 위해서는 동적 주소 변환이 신속하게 수행되어야한다.
 
 보다 개선된 방법중 하나는 주기억장치보다 훨씬 빠른 접근 시간을 가지고 있는 연관기억장치에 페이지 사상 테이블 전체를 넣는 방법
 
 이 방법은 저장된 값을 이용하여 데이터를 접근(access)하는 내용 주소화 메모리(CAM: Content Addressable Memory)와 찾고자 하는 내용의 일부를 기억하는 데이터 레지스터가 운영된다.
 
 페이지 p 에 대응하는 프레임 p'를 찾아내어 변위 d를 더함르호써 실제주소 r = p' + d를 구한다.
 
 연관 사상 테이블(assoicative mapping talbe)로 향하는 포인터들이 실제로 사상 테이블의 모든 단위 항목으로 들어감에 유의한다.
 
 접근할 내뇽의 일부분이 존재하는 p와 일치하는 내용을 찾기 위하여 연관기억장치의 모든 단위 항목을 동시에 조사하며, 이겅ㅅ은 신속한 동적 주소 변환을 가능하게 한다.
 
 하지만 연관기억장치는 고가이기 때문에 페이지 사상 테이블 전체를 위한 연관 기억장치의 설치에는 비싼 대가를 지불한다. 그래서 저가의 직접 사상 방버과 고가의 연관사상 방법을 효율적으로 혼합한 형태로 사용한다.
 
 
 ------------------------------------------------------------
 
 
 ### 연관 / 직접 사상
 
 캐시기억장치만을 사용한 순수한 직접 사상의 구현이나 연관기억장치만을 사용한 순수한 연관 사상의 구현은 주기억장치보다 비용이 너무 많이 들기 때문에,
 
 보다 적당한 비용으로 캐시나 연관기억장치 기법에 의한 장점을 살릴 수 있는 절충 방안이 등장했다.
 
 가장 최근에 참조된 페이지는 조만간 다시 사용되기 귑다는 사실을 이용하여 연관기억장치에는 페이지 사상 테이블의 전체 항목 중 가장 최근에 참조된 일부 페이지 항목들만을 수용하는 것이다.
 
 이때, 보다 좋은 성능을 위하여 부분적인 연관 페이지 사상 테이블이 반드시 커야 할 필요는 없다.
 
 이 부분적 수용 시스템들은 90% 이상의 성능을 가진다고 한다.
 
 동적 주소 변환은 다음과 같이 진행한다.
 
 페이지 p를 연관 페이지 사상 테이블에서 찾는다. 이 테이블에서 가상 페이지 p에 대한 항목을 찾으면 p와 대응되는 페이지 프레임 번호 p'를 얻고 이를 변위 d에 접속하여 가상 주소 v = (p,d) 에 대한 실제주소 r = p' + d를 구한다.
 
 만약 p와 일치하는 항목이 연관 페이지 사상 테이블에 없으면 우선, 직접 페이지 사상 테이블의 주기억ㅈ아치 주소를 페이지 사상 테이블 시작점 레지스터에 넣는다. 그 후
 
 직접 페이지 사상 테이블의 시작주소 b를 페이지 변호 p에 더하여 p에 대한 항목의 주기억ㅈ아치 주소인 b + p를 형성한다. 이 주소에 해당 하는 항목을 찾아서 가상 페이지 p에 대응되는 페이지 프레임 p'를 얻고,
 
  이어 p'는 변위 d와 접속되어 가상 주소 v = (p,d)에 대한 실제주소 r = p' + d를 구한다.
  
  ### 페이징 시스템의 공유
  
  다중 프로그래밍이 가능한 컴퓨터 시스템, 특히 시분할 환경 하에서는 여러 사용자가 동일한 프로그램을 동시에 수행시키는 경우가 흔히 있다.
  
이는 기억장치의 낭비를 발생 시키는데, 해결책으로 공유가 가능한 페이지를 가능한 한 공유하도록 하는 것이다.

수정이 불가능한 프로시듀어를 순수 프로시듀어(pure procedure) 또는 재진입가능 프로시듀어(reentrant procedure) 라고 하는데

만약 이 코드가 재진입되면 이는 수행중 결코 변경되지 않기 때문에 공유가 가능하며 수정이 가눙한 데이터는 공유될 수 없다.

따라서 각 페이지의 공유가 가능한지 아닌지를 정의해 둘 필요가 있다는 것.


------------------------------------------------------------

### 페이지 크기

페이지 시스템에 있어서 실제 기억 장치는 일반적으로 고정된 크기의 페이지 프레임으로 나누어지는데 이러한 페이지 프레임의 크기는 얼마로 할 것인가,

모든 페이지를 같은 크기로 할 것인가등 여러가지 의문이 생기는데 정해진 정답은 없다.

페이지의 크기를 결정함에 있어 고려할 요소는 다음과 같다.

```
 - 테이블 단편화 : 페이지 크기가 작으면 작을수록 보다 맣은 페이지와 페이지 프레임이 존재하게 되고 이를 관리하기 위한 페이지 테이블의 크기가 증가하여 기억 공간이 낭비된다.
이러한 기억장소의 낭비 현상을 테이블 단편화(table fragmentiation)라고 한다.

-작업세트 : 페이지 크기가 작을수록 프로세스가 작업세트(working set)를 확보하는 데 도움이 된다. 프로세스들은 구역성을 가지며, 이 구역 내에서는 비교적 소량의 정보만을 필요로 하기 때문이다.

- 실제로 프로시듀어나 데이터 블록의 단위는 대부분 페이지 크기의 정수 배가 아니므로 페이징 시스템은 단편화 현상을 초래하게 된다. 마지막 페이지가 보통 평균적으로 1/2 페이지의 단편화가 생기게된다.
따라서 페이지 크기가 작을 수록 내부의 단편화는 감소된다.
 
- 페이지가 크게되면 참조되지 않을 많은 정보들까지 주기억장치로 옮겨지게 되어 기억공간의 낭비를 초래한다.

- 디스크로부터의 입출력 전송은 많은 시간이 소비되기 때문에 프로그램 실행 중 입출력 전송의 횟수를 줄이기 위해서는 페이지 크키가 클수록 효과적이다.
```

------------------------------------------------------------

### 페이지 인출 기법

사용자에 의해 작성된 프로그램은 실행에 앞서 일차적으로 보조기억장치에 놓이게된다.

보조기억ㅈ아치로부터 페이지 단위로 주기억장치로 옮겨지는 방법에는 두가지 기법이 적용되고 있다.

```
1. 요구 페이징 기법(demand paging) : 실행 중인 프로세스에 의하여 명백히 참조되는 프로세스만이 보조기억장치로부터 주기억장치로 옮겨진다.

장점
- 요구 페이징 기법에서는 주기억장치에 옮겨진 페이지들이 모두 프로세스에 의해 실제로 참조된 것임을 확신 할 수 있다.
- 프로그램 실행순서는 정확히 예측될 수 없기 때문에 새롱누 페이지들을 짐작으로 주기억장치에 미리 적재시키는 일은 잘못된 결과를 초래할 수 도 있다.
- 어느 페이지를 주기억장치로 옮길 것인가를 결정하기 위한 오버 헤드를 최소화 할 수 있다.

단점
- 새로운 페이지가 필요할 때 마다 한 번에 하나의 그 페이지를 적재시켜야 한다.
- 새로운 페이지가 적재될 때마다 그 프로세스는 페이지가 주기억장치로 옮겨질 때까지 아무 일도 못하고 대기 해야한다.
- 프로세스에게 할당된 페이지 수가 많을 수록 대기로써 낭비되는 기억장치의 희생은 커지기 마련이다.


2. 예상 페이징(anticipatory paging) 기법 : 운영체제가 예측하여 주기억장치에 여유가 있을 때 이 페이지들을 미리 적재 시킨다.
결정이 옳았다면 그 프로세스는 가능한 최소의 페이지 부재율을 가지게 실행됨으로써 실행 시간은 상당히 줄게 된다. 프로세스가 현재 주기억장치에 있는 페이지들로서 실행되는 동안
시스템은 프로세스가 추후 요규할 때 즉시 사용할 수 있도록 새로운 페이지들을 주기억장치에 적재시킨다.

장점
- 예측 결정이 옳았으면 프로세스 실행 시간은 많이 감소된다.
- 만일 이러한 예측이 비교적 적은 오버헤드로 내려질 수 있다면, 주어진 프로세스의 실행은 다른 실행 중인 프로세스에 영향을 주지 않고 가속화될 수 있다.
- 컴퓨터 하드웨어 값이 더욱 저렴해짐에 따라, 예상 페이징 기법이 실기억장치에 적재할 초과량의 페이지들을 수용할 수 있는 정도의 주기억장치를 하나 더 설치할 수 있다.
```

------------------------------------------------------------

### 페이지 양도(page release)

프로그램에서 더 이상 필요로 하지 않는 특정한 페이지가 존재한다면 작업 세트로부터 그것을 제외시켜 페이지 프레임을 유용하게 만들어야 할 것이다.

이를 위해 사용자가 자발적으로 페이지를 양도함으로써 주기억장치 내에서 사용되지 않는 페이지를 제거할 수 도 있는데, 이렇게 함으로써 프로세스가 작업세트 내에 더이상

불필요한 페이지를 보유하는 단점을 극복할 수 있다.

하지만 이러한 페이지 제거는 기억 공간의 낭비를 방지하고 프로그램의 실행을 빠르게 하지만, 오늘날의 많은 사용자들은 컴퓨터 시스템에서 페이지라는 것의 구체적인 개념을 알지도 못하고,

또 일반 사용자들에게 시스템 수준의 페이지 양도 명령을 내리도록 하는 것도 바람직한 일은 아니다.

또한 페이지 양도 명령을 사용자 프로그램에 일임하는 것은 응용 프로그램의 개발을 대단히 느리게 할 수도 있기 때문에,

가장 효율적인 페이지 양도 방법은 컴파일러나 운영체제가 자동으로 페이지 제거를 실행하여 작업세트를 확보하도록 하는 것이 바람직하다.
