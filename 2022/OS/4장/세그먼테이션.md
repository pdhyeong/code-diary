### 세그먼테이션(Segmentation)

페이징은 일정한 단위로 프로그램을 분할 하는 기법이었다면 세그먼테이션 기법에서는 고정된 단위가 아니고

서로 논리적으로 관련이 있는 정보의 단위로 프로그램을 분할 한다.

사용자가 작성하여 실행하는 프로그램을 고려한다 했을때, 각종 서브루틴과 함수, 프로시듀어 또는 모듈의 집합으로 구성되어 있고,

테이블, 행렬 또는 스택 등 여러가지 자료구조 형태로 있다.

이때 논리적 단위가 되는 프로그램 모듈이나 자료구조 등을 세그먼트(Segment)라고 한다.

기억장치 내에서 어떤 주소에 위치하는가에 관계없이, 각종 모듈 또는 자료구조 등과 같은 세그먼트의 이름으로 참조 된다.

세그먼트는 고유의 이름과 길이를 가진다.(페이지는 주소)

따라서 참조되는 주소는 세그먼트 이름과 세그먼트 내의 변위(displacement)로 표현 된다.

세그먼트를 다시 고정된 크기의 페이지로 분할하여 사용할 수도 있다. 이것을 전에 말했던 세그먼트/페이징 혼용 기법이라고 한다.

------------------------------------------------------------

### 직접 사상

페이징 기법의 시스템에서와 같이 직접 사상에 의한 방법, 연관 사상에 의한 방법, 또는 직접/연관 사상의 혼합된 방법 등이 있는데,

세그먼트 사상 테이블 전체를 수용할 만큼 큰 캐시기억장치를 가지고 구현할 수 도 있고, 많이 참조된 세그먼트만을 사용할 정도의 부분적 캐시기억장치로 구현할 수 도 있다.

현재는 고속 엑세스의 캐시기억장치에 전체 세그먼트 사상 테이블을 기억시키고 직접 사상을 통한 주소변화를 생각한다.

가상 메모리의 세그먼트 번호를 s라 하고 이 세그먼트 s 내에서의 변위를 d라 할 때, 세그먼테이션 시스템에서의 가장 주소는 v = (s,d)이다.

어떤 프로세스에 의해 참조되는 세그먼트가 현재 주기억장치에 있으면, 그 프로세스는 계속 수행될 수 있다. 

하지만 만약 주기억장치에 존재하지 않는다면 해당 세그먼트는 보조기억장치로부터 주기억장치로 옮겨져야 하고 주기억장치에 옮겨지는 세그먼트는 그것이 들어갈 만큼의 충분한 주기억장치가 연속적으로 확보 되어야 한다.

이때 주기억장치 배치 전략은 가변분할 다중 프로그래밍에서 이용한 방법과 동일하고, 가장 일반적인 방법은 최초 적합과 최적 적합이다.

<br>
#### 세그먼테이션에서의 동적 주소 변환 

가상메모리 상의 주소 v = (세그먼트번호(s),변위(d))를 세그먼트 번호를 세그먼트 사상 테이블 시작 레지스터(segment map table origin register)에 있는

시작주소 b에 더하여 주기억장치 주소 b + s를 만들고 이 주소를 가지고 세그먼트 사상 테이블에서 세그먼트 s에 대한 항목을 찾는다.

그러면 주기억장치 상의 위치 s'가 시작되는대 이 s'에 변위 d를 더하여 가상 주소 v = (s,d)에 대응되는 실제 주소 r = s' + d를 구한다.

<br>

|세그먼트 존재 비트|보족기억 장치 주소(실기억 장치내에 없는경우)|세그먼트 길이|보호비트|세그먼트의 시작주소(실내 기억장치에 있는경우)|
|:-----:|:----:|:-----:|:-------:|:------:|
|r|a|l|R,W,E,A|s'|

위 표는 세그먼트 사상 테이블을 구성하는 각 항목이 전형적인 형식으로서, 존재 비트(resident bit) r은 해당 세그먼트가 주기억장치에 현재 존재하는지의 여부를 나타내며,

만일존재한다면 s'는 그 세그먼트가 시작되는 주기억장치의 주소를 가리킨다. 하자만 없다면 a는 프로세스 수행전 세그먼트가 검색되어야 하는 보조기억장치의 주소가된다.

세그먼트에 대한 참조는 세그먼트의 범위 안에 있어야함을 분명히 하기 위해 세그먼트의 길이 l을 점검한다.

이처럼 동적 주소 변환을 하는 최초의 괒어은 세그먼트 존재 비트 r을 점검함으로써 해당 세그먼트의 주기억장치 존재 여부부터 점검한다.

주기억장치 내에 없음녀 세그먼트 부재 결함(segment missing fault)을 발생시켜 운영체제로 하여금 보조기억장치의 주소로 부터 참조하여야할 세그먼트를 적재시키도록한다.

일단 세그먼트가 적재되면 벼누이 d가 세그먼트의 길이 l보다 작거나 같은지를 점검하면서 주소 변환이 진행된다. 만일 d가 l 보다 크면,

세그먼트 오버플로우 결함(segment overflow fault)을 발생시켜 운영체제가 제어를 받아서 그 프로세스에 대한 처리를 종결한다.

만일 변위가 세그먼트의 범윈 내에 있다면 작업이 허용될 수 있는가를 확인하기 위해 보호비트(protection bit)를 검사한다.

허용된다면 최종적으로 주기억장치 내의 해당 세그먼트의 시작 주소 s'와 변위 d를 더하여 주기억장치주소 r = s' + d를 얻는다.

------------------------------------------------------------


### 공유 및 보호

페이징 기법에 대한 세그먼테이션 기법의 장점 중 하나는 물리적인 개념이 아니라 논리적 개념이라는 점이다.

세그먼테이션 기법에서는 세그먼트가 특정크기를 갖도록 제한을 가하지 않고, 합리적인 범위 내에서 필요한 크기를 가지도록 허용하는 것.

즉 하나의 배열에 대응되는 배열과 동일한 크기를 가지도록 하고, 동적 자료구조에 대응되는 것은 자료구조 자체가 가지는 크기만큼 거질수도 있고 작아질 수도 있다.

세그먼트는 컴파일러에 의해 만들어지는 프로시듀어 코드(procedural code)를 수용할 만큼의 크기까지 허용된다.
<br><br>
#### 1. 공유 

세그먼트의 공유는 페이징 시스템에서의 공유와 비교할 때 매우 단순한데,

순수 페이징 시스템에서 새 페이지 반 정도 크기의 배열이 공유된다면 이 배열이 차지하는 각 페이지 마다 공유됨을 나타내기 위한 각 항목을 가져야 한다.

부분적 페이지를 조작하는 것은 지루하고, 동적자료구조에서의 상황은 어려워진다.

그러나 세그먼테이션 시스템에서 어떤 세그먼트가 공유된다고 선언되고나면 자료구조는 그것이 공유된 세그먼트 내에 있다는 논리적인 사실을 바꾸지 않고도 
크기를 임의로 늘이거나 줄일 수 도 있게 된다.

<br><br>
#### 보호를 위한 접근 제어

앞에서와 깉이 여러 사용자 프로세스가 임의의 세그먼트를 공유한다고 해서 모든 세그먼트를 무제한으로 접근하는 것은 바람직하지 못하다.

사실 세그먼테이션 시스템의 또 다른 장점 중의 하나는 세심한 접근 제어가 가능하다는 점이다.


**접근제어 유형** 

|접근형태|약자|설명|
|----|----|-------|
|판독|R|이 블록은 읽힐 수 있다.|
|기록|W|이 블록은 수정될 수 있다.|
|수행|E|이 블록은 수행될 수 있다.|
|첨가|A|이 블록의 끝에 정보를 첨가할 수 있다.|

<br>

판독 접근 권한을 가지면 어떠한 정보 항목을 얻을 수 있게 되고, 그 프로세스가 원한다면 그 세그먼트의 전체 사본을 만들 수 있다.

기록 접근 권한을 가지면 세그먼트에 대한 추가정보도 넣을 수 있고, 프로세그가 원한다면 모든 정보를 파괴할 수 있다.

수행 접근 권한을 가지면 세그먼트를 하나의 프로그램으로 수행시킬 수는 있지만 데이터 세그먼트에 대한 수행 접근은 있을 수 없다.

첨가 접근 권한을 가지면 세그먼트의 끝에다 추가 정보를 넣을 수 는 있으나 기존의 정보를 고칠 수는 없다.

위의 4가지 접근 제어 형태를 가지고 있는 시스템에서,

각각의 유형을 허용하든 허용하지 않든 간에 16가지의 접근 제어 양식(access control mode)을 만들 수 있는데,

이중 실제로 유용하지 않은 것도 있어서 간단하게 줄여서 판독,기록, 수행 접근으로 구성된 8가지의 조합만 예시로 든것.
