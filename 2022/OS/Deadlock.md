## 데드락


교착상태란

두 개 이상의 프로세스가 서로 상대방의 작업이 끝나기만을 기다려서 아무것도 진행되지 못하는 상태

둘이상의 프로세스 혹은 스레드가 한정된 자원을 얻지 못해 다음 처리를 진행하지 못한 상태



데드락의 발생조건

상호 배제 : 하나의 공유 자원에 대해 두개의 프로세스가 접근할 수 없다.
점유대기 : 하나의 자원을 점유하고 있는 프로세스가 다른 프로세스에게 자원을 요청할때 요청을 보내고 대기 해야한다.
비선점 : 특정 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되기 전까지 점유할 수 없다.
순환 대기 : 프로세스들이 서로 사용하고 있는 자원에 대해서 서로 대기 하고 있다.


해결방법

1. 교착 상태 예방
	-  상호 배제 조건 제거 : 하나의 공유자원에 대해 두개다 공유하는것
	-  점유 대기 조건 제거 : 전부 요청하고 전부 할당받고 작업을 진행하는 방법으로 제거 가능 (오버헤드가 큼)
	- 비선점 조건 제거 : 다른 프로세스의 자원을 요청할때 자기가 가지고 있던 자원을 반납한다.(여태까지 상태를 이길 수 있게된다는 단점)
	- 순환 대기 조건 제거 : 각 프로세스간의 자원들에 고유번호를 할당하고 자원의 번호 기준으로 오름차순이나 내림차순으로만 할당 받을 수 있게 한다.

2. 교착 상태 회피 : 
	1.  프로세스가 자원 요청시 자원을 할당한 후 에도 안정 상태로 남아있는지 사전 검사
	2.  안정 상태라면 자원 할당
	3. 불안정 상태라면 다른 프로세스가 자원을 해지할 때까지 대기
	
	자원을 요청할 때마다 시스템 상태를 검사하는 만큼 오버헤드가 크다.
	
	은행원 알고리즘의 경우 전제 조건이 많다.

3. 교착 상태 탐지 및 회복 : 교착 상태를 허용하지만 상태를 탐지하고 회복하는 방식으로 알고리즘을 주기적으로 실행함으로써, 시스템에 발생한 데드락을 체크하고 회복
	- 자원할당 그래프 알고리즘 : 그래프 상의 교착 상태를 유발시키는 순환 사이클의 존재 유무를 체크한다. (체크 주기를 짧게 잡으면 회피처럼 오버헤드가 커짐)
	- 교착 상태를 일으킨 프로세스를 종료하거나 할당된 자원을 해제함으로써 회복
			1. 프로세스 종료 : (ㄱ) 교착 상태의 프로세스를 모두 중지 (ㄴ) 교착 상태가 제거될 때까지 한 프로세스씩 중지
			2. 자원 선점 : 교착상태가 제거될 때까지 프로세스가 점유한 자원을 선점해  다른프로세스에게 할당
	- 회복시 고려 사항: 
			- 희생자 선택 :  데드락에서 회복시 어떤 프로세스를 죽일지 기준은 대부분 비용 측면에서 본다. 너무 비용만 보면 기아 상태가 발생(starvation)
			- 후퇴(Rollback) : 희생자를 선택했다면 어느정도 수준으로 되돌릴지
			- 기아 상태 : 끊임없이 자원을 가지지 못하는 상태
	
4. 교착 상태 무시
	- 교착 상태를 자체를 무시하고 특별한 조치를 취하지 않는 방법으로 교착 상태의 발생 확률 이 낮은 상황에서 주로 사용한다. 탐지나 회복하는 상황에서 발생하는 오버헤드가 더 크다고 생각하여 무시하는것. 발생한다면 그냥 재부팅하거나 종료한다.

--------------------------------------------------------

## 세마포어 뮤텍스의 차이점

임계구역(critical section)

 병렬컴퓨팅에서 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원(자료 구조 또는 장치)을 접근하는 코드의 일부를 말한다. 임계 구역은 지정된 시간이 지난 후 종료된다.

데이터를 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 두는 동기화 방식을 취해야 한다.

동기화 도구에는 대표적으로 뮤텍스(Mutex)와 세마포어(Semaphore)가 있다.


뮤텍스

동시 프로그래밍에서 공유 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘
* 임계구역(Critical Section)을 가진 스레드들의 실행시간(Running Time)이 서로 겹치지 않고 각각 단독으로 실행(상호배제_Mutual Exclution)되도록 하는 기술
* 한 프로세스에 의해 소유될 수 있는 Key를 기반으로 한 상호배제 기법
    * Key에 해당하는 어떤 객체(Object)가 있으며, 이 객체를 소유한 스레드/프로세스만이 공유자원에 접근할 수 있다.
* 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 동기화(Synchronization) 또는 락(Lock)을 사용.
* 즉, 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없다.



세마포어(Semaphore)

멀티 프로그래밍 환경에서 공유된 자원에 대한 접근을 제한하는 방법

* 공유자원의 상태를 나타낼 수 있는 카운터로 생각할 때,
    * 사용하고 있는 스레드/프로세스의 수를 공통으로 관리하는 하나의 값을 이용해 상호배제를 달성한다.
    * 운영체제 또는 커널의 한 지정된 저장장치 내의 값
    * 일반적으로 비교적 긴 시간을 확보하는 리소스에 대한 이용
    * 유닉스 프로그래밍에서 세마포어는 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 또는 동기화하는 기술
* 공유 자원에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근할 수 있다.
* 각 프로세스는 세마포어의 값을 확인하고 변경할 수 있다.
* 자원을 사용하지 않는 상태가 될 때, 대기하던 프로세스가 즉시 자원을 사용한다.
* 이미 다른 프로세스에 의해 사용중이라는 사실을 알게 되면, 재시도 전에 일정시간 대기해야 한다.
* 세마포어를 사용하는 프로세스는 그 값을 확인하고, 자원을 사용하는 동안에는 그 값을 변경함으로써 다른 세마포어 사용자들이 대기하도록 해야 한다.
* 세마포어는 이진수를 사용하거나 추가적인 값을 가질 수 있다.




뮤텍스와 세마포어의 차이점
1. 가장 큰 차이점은 동기화 대상의 갯수이다.
    1. Mutex는 동기화 대상이 only 1개일 때 사용
    2. Semaphore는 동기화 대상이 1개 이상일 때 사용
2. 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다.
    1. Mutex는 0, 1로 이루어진 이진 상태를 가지므로 Binary Semaphore!
3. Mutex는 자원 소유 가능 + 책임을 가지는 반면, Semaphore는 자원 소유 불가
    1. 뮤텍스는 상태 0, 1 뿐이므로 Lock 가질 수 있음
4. Mutex는 소유하고 있는 스레드만이 이 Mutex를  해제할 수 있다.
    1. 반면, Semaphore는 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있다.
5. Semaphore는 시스템 범위에 걸쳐 있고, 파일 시스템 상의 파일로 존재한다.
    1. 반면, Mutex는 프로세스의 범위를 가지며 프로세스 종료될 때 자동으로 Clean up 된다.
 
뮤텍스와 세마포어는 모두 완벽한 기법은 아니므로, 데이터 무결성을 보장할 수 없으며 모든 교착 상태를 해결하지는 못한다.
하지만, 상호배제를 위한 기본적인 기법이며 여기에 좀 더 복잡한 매커니즘을 적용해 개선된 성능을 가질 수 있도록 하는 것이 중요하다.
