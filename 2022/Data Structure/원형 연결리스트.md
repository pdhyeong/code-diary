## 원형 연결 리스트

원형 연결리스트는 단순히 노드의 추가가 아닌

노드의 추가 위치에 의미를 부여해서 머리에 추가하는 것과 꼬리에 추가를 동시에 거론하는 경우를 들 수 있다.

보통 웬만한 강의에서 잘 다루진 않지만 CLinked List 만의 장점이 있기 때문에 봐보자

--------------------------------------------------------

## CODE

```C
#include <stdio.h>
#include <stdlib.h>

#define TRUE   1
#define FALSE  0

typedef int LData;

typedef struct _node
{
  LData data;
  struct _node * next;
} Node;

typedef struct _CLL
{
  Node * tail;
  Node * cur;
  Node * before;
  int numOfData;
} CList;

typedef CList List;

// 초기화
void ListInit(List * plist)
{
  plist->tail = NULL;
  plist->cur = NULL;
  plist->before = NULL;
  plist->numOfData = 0;
}

// 꼬리에 추가
void LInsert(List *plist,LData data)
{
  Node * newNode = (Node *)malloc(sizeof(Node));
  newNode->data = data;

  if(plist->tail == NULL)
  {
    plist->tail = newNode;
    newNode->next = newNode;
  }
  else
  {
    newNode->next = plist->tail->next;
    plist->tail->next = newNode;
    plist->tail = newNode;
  }
  (plist->numOfData)++;
}

// 머리에 추가
void LInsertFront(List *plist,LData data)
{
  Node * newNode = (Node *)malloc(sizeof(Node));
  newNode->data = data;

  if(plist->tail == NULL)
  {
    plist->tail = newNode;
    newNode->next = newNode;
  }
  else
  {
    newNode->next = plist->tail->next;
    plist->tail->next = newNode;
  }
  (plist->numOfData)++;
}

// 첫번째 데이터 참조
int LFirst(List *plist,LData *pdata)
{
  if(plist->tail == NULL)
  {
    return FALSE;
  }
  plist->before = plist->tail;
  plist->cur = plist->tail->next;

  *pdata = plist->cur->data;
  return TRUE;
}

// 다음 데이터들 확인 및 할당
int LNext(List *plist,LData *pdata)
{
  if(plist->tail == NULL)
    return FALSE;
  plist->before = plist->cur;
  plist->cur = plist->cur->next;

  *pdata = plist->cur->data;
  return TRUE;
}

// 데이터 삭제
LData LRemove(List *plist)
{
  Node *rpos = plist->cur;
  LData rdata = rpos->data;

  if(rpos == plist->cur)
  {
    if(plist->tail == plist->tail->next)
      plist->tail = NULL;
    else
      plist->tail = plist->before;
  }
  plist->before->next = plist->cur->next;
  plist->cur = plist->before;
  
  free(rpos);
  
  (plist->numOfData)--;
  return rdata;
}

int LCount(List *plist)
{
  return plist->numOfData;
}

int main() {
  List list;
  int data, i , nodeNum;
  ListInit(&list);

  LInsert(&list,3);
  LInsert(&list,4);
  LInsert(&list,5);
  LInsertFront(&list,2);
  LInsertFront(&list,1);

  if(LFirst(&list, &data))
  {
    printf("들어가 있는 데이터의 수 %d \n",LCount(&list));
    
    printf("%d ",data);
    
    for(i = 0;i<LCount(&list)-1;i++)
      {
        if(LNext(&list,&data))
          printf("%d ",data);
      }
  }
  printf("\n");

  nodeNum = LCount(&list);

  // 2의 배수 삭제
  printf("2의 배수 삭제 후 리스트 \n");
  if(nodeNum != 0)
  {
    LFirst(&list,&data);
    if(data % 2 == 0)
      LRemove(&list);
    for(i = 0;i<nodeNum-1;i++)
    {
      LNext(&list,&data);
      if(data % 2 == 0)
        LRemove(&list);
    }
  }

  if(LFirst(&list,&data))
  {
    printf("%d ",data);

    for(i = 0;i<LCount(&list)-1;i++){
      if(LNext(&list,&data))
        printf("%d ",data);
    }
  }
  return 0;
}
  
```
