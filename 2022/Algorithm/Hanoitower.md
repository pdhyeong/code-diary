## 백준 11729

### 하노이 타워

하노이의 탑(Tower of Hanoi)은 퍼즐의 일종이다. 

세 개의 기둥과 이 기둥에 꽂을 수 있는 크기가 다양한 원판들이 있고, 퍼즐을 시작하기 전에는 한 기둥에 원판들이 작은 것이 위에 있도록 순서대로 쌓여 있다.

게임의 목적은 다음 두 가지 조건을 만족시키면서, 한 기둥에 꽂힌 원판들을 그 순서 그대로 다른 기둥으로 옮겨서 다시 쌓는 것이다.

조건 3가지를 이용해서 쌓아올리는것 

#### 조건)
    * 1. 한 번에 한개의 원판만 옮길 수 있다.
    * 2. 가장 위에 있는 원판만 이동할 수 있다.
    * 3. 큰 원판이 작은 원판 위에 있어서는 안 된다.
![image](https://user-images.githubusercontent.com/71219602/167301624-ea8ef049-9beb-4a8b-86d9-9347e1bd020d.png)

### 코드

``` Cpp

#include <iostream>
using namespace std;
void hanoi(int n, int start, int to, int by) // from은 시작 기둥, to는 마지막으로 가는 목표기둥  by는 중간에 들릴 보조 기둥으로 설정했다.
{
	if (n == 1) {
		cout <<"원반을 "<< start << "에서 " << " " << to << "로 옮긴다. " << endl;
	}
	else {
		hanoi3(n - 1, start, by, to);
		cout << "원반을 " << start << "에서 " << " " << to << "로 옮긴다. " << endl;
		hanoi3(n - 1, by,to, start);
	}
}
int main() {
	int num = 3; // 원반의 개수
	int ki = (1 << num) - 1; // 하노이 타워에 최소값이 나오는 공식으로 1 << 3은 1의 num제곱으로 값은 8 이다. 
	cout << ki << endl; 
	hanoi(num, 1, 3, 2); 
	return 0;
}
```


### 설명 
원반이 1개일 때를 가정하면 시작기둥에서 원반을 목표기둥으로 옮긴다.

```Cpp
if (n == 1) cout <<"원반을 "<< start << "에서 " << " " << to << "로 옮긴다. " << endl;
```

원반이 2개일때는 시작기둥에서 보조기둥과 목표기둥으로 둘다 옮길수 잇으나 목표기둥에 가장 큰 원반이 가야하므로 보조기둥에 원반을 둔다.

여기서 핵심은 가장큰 원반을 제외한 원반을 보조기둥에 옮겨놔야한다는 것

```Cpp
hanoi3(n - 1, start, by, to);
```

다 옮기고 나면 시작기둥에는 원반이 1개가 남으므로 원반이 1개일때처럼 목표기둥으로 옮긴다.

```Cpp
cout <<"원반을 "<< start << "에서 " << " " << to << "로 옮긴다. " << endl;
```
현재 가장 큰 원반이 목표기둥에 있고 이 기둥은 옮기지 않아도 되므로 원반의 갯수를 1개를 뺀다.(n-1)

지금상태는 보조기둥에 나머지 원반들이 올라가있고 목표기둥에 가장 큰 원반이 올라가 있는상태이다.

그러면 보조 기둥을 시작기둥으로 바꾸고 비어있는 시작 기둥은 보조기둥이 된다.

```Cpp
hanoi3(n - 1, by,to, start);
```


### 실행결과 

7<br>
원반을 1에서 3로 옮긴다.<br>
원반을 1에서 2로 옮긴다.<br>
원반을 3에서 2로 옮긴다.<br>
원반을 1에서 3로 옮긴다.<br>
원반을 2에서 1로 옮긴다.<br>
원반을 2에서 3로 옮긴다.<br>
원반을 1에서 3로 옮긴다.<br>

### 끝마치며

재귀 함수의 동작 방식을 안다고 해도 내가 직접이런 풀이를 생각해서 풀진 못했을거다..... 워낙 잘 알려진 알고리즘이라 설명을 보고 코드를 짜는것에 만족했다.

이해가는것에 시간이 오래걸렸지만 그만큼 까먹지 않고 계속 기억 날것 같다.

그림 참고 : https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/
