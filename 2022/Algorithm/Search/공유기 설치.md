### 문제

도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, ..., xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.

도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다.

최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 

가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.

C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.

-----------------------------------------

### 입력

첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (0 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.

------------------------------------------------------------

### 출력

첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다.

--------------------------------------------------------

### 예제 입력 1 
```
5 3
1
2
8
4
9
```
### 예제 출력 1 

3

------------------------------------------

### 힌트

공유기를 1, 4, 8 또는 1, 4, 9에 설치하면 가장 인접한 두 공유기 사이의 거리는 3이고, 이 거리보다 크게 공유기를 3개 설치할 수 없다.

-------------------------------------------

### 처음나의 생각

문제 이해를 잘 못해서 왼쪽부터 설치하는게 아니라 양쪽에 설치하고 이진탐색으로 중간 지점에 설치하고 또 왼쪽 오른쪽을 기준으로 나누어서

그 값의 중간 지점에 설치하는 식으로 풀려고했는데 왼쪽 부터 공유기를 설치하는 방법으로 풀어야 답이 나온다고 한다.

--------------------------------------------

### CODE

```C++
#include <iostream>
#include <vector>
#include<algorithm>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	vector<int> ve;
	vector<int> ins;
	/*
	int n;
	cin >> n;

	for (int i = 0; i < n; i++)
	{
		int k;
		cin >> k;
		ve.push_back(k);
	}
	cout << bs(ve, 0, n) << endl;
	*/
	int n, m;
	cin >> n >> m;

	for (int i = 0; i < n; i++)
	{
		int k;
		cin >> k;
		ve.push_back(k);
	}

	sort(ve.begin(), ve.end());
	
	int start = 1; // 최소거리
	int end = ve[n - 1] - ve[0]; // 최대거리
	int result = 0;

	while (start <= end)
	{
		int mid = (start + end) / 2; // 설치 지점
		int value = ve[0]; // 설치하면서 값 비교할 변수
		int count = 1;

		for (int i = 1; i < n; i++)
		{
    // 직전 설치 한 지점과 거리차이 보다 현재 설치한 지점의 거리가 더 멀때
			if (ve[i] >= value + mid)
			{
				value = ve[i];
				count += 1;
			}
		}
    // m의 입력값보다 크거나 같으면 정답 갱신하고 설치 거리를 위해 거리를 뒤로 민다.
		if (count >= m)
		{
			start = mid + 1;
			result = mid;
		}
    // 거리가 멀면 거리를 앞으로 땡긴다.
		else {
			end = mid - 1;
		}
	}

// 갱신된 결과 값 출력
	cout << result << endl;
	
	return 0;
}
```

--------------------------------------------

### 후기

파라메트릭 서치를 이용한 방법으로 아무것도 모르는 상태에서 풀기에는 상당히 어려운 문제였던 것 같다.

이진탐색의 숙달이 필요하다고 생각하는 문제였다.
