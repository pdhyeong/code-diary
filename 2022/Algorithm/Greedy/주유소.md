## 백준 13305 주유소

### 문제
어떤 나라에 N개의 도시가 있다. 

이 도시들은 일직선 도로 위에 있다. 편의상 일직선을 수평 방향으로 두자. 

제일 왼쪽의 도시에서 제일 오른쪽의 도시로 자동차를 이용하여 이동하려고 한다.

인접한 두 도시 사이의 도로들은 서로 길이가 다를 수 있다. 도로 길이의 단위는 km를 사용한다.

처음 출발할 때 자동차에는 기름이 없어서 주유소에서 기름을 넣고 출발하여야 한다. 

기름통의 크기는 무제한이어서 얼마든지 많은 기름을 넣을 수 있다. 도로를 이용하여 이동할 때 1km마다 1리터의 기름을 사용한다. 

각 도시에는 단 하나의 주유소가 있으며, 도시 마다 주유소의 리터당 가격은 다를 수 있다. 가격의 단위는 원을 사용한다.

예를 들어, 이 나라에 다음 그림처럼 4개의 도시가 있다고 하자. 원 안에 있는 숫자는 그 도시에 있는 주유소의 리터당 가격이다. 

![image](https://user-images.githubusercontent.com/71219602/170998815-783efe3f-3df2-4ae2-89c2-031391903252.png)

도로 위에 있는 숫자는 도로의 길이를 표시한 것이다. 

제일 왼쪽 도시에서 6리터의 기름을 넣고, 더 이상의 주유 없이 제일 오른쪽 도시까지 이동하면 총 비용은 30원이다.

만약 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원) 다음 번 도시까지 이동한 후 3리터의 기름을 넣고(3×2 = 6원)

다음 도시에서 1리터의 기름을 넣어(1×4 = 4원) 제일 오른쪽 도시로 이동하면, 총 비용은 20원이다. 

또 다른 방법으로 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원)

다음 번 도시까지 이동한 후 4리터의 기름을 넣고(4×2 = 8원) 제일 오른쪽 도시까지 이동하면,총 비용은 18원이다.

각 도시에 있는 주유소의 기름 가격과, 각 도시를 연결하는 도로의 길이를 입력으로 받아 제일 왼쪽 도시에서 제일 오른쪽 도시로 이동하는 최소의 비용을 계산하는 프로그램을 작성하시오.

### 입력

표준 입력으로 다음 정보가 주어진다.

첫 번째 줄에는 도시의 개수를 나타내는 정수 N(2 ≤ N ≤ 100,000)이 주어진다. 

다음 줄에는 인접한 두 도시를 연결하는 도로의 길이가 제일 왼쪽 도로부터 N-1개의 자연수로 주어진다.

다음 줄에는 주유소의 리터당 가격이 제일 왼쪽 도시부터 순서대로 N개의 자연수로 주어진다.

제일 왼쪽 도시부터 제일 오른쪽 도시까지의 거리는 1이상 1,000,000,000 이하의 자연수이다. 리터당 가격은 1 이상 1,000,000,000 이하의 자연수이다. 

### 출력

표준 출력으로 제일 왼쪽 도시에서 제일 오른쪽 도시로 가는 최소 비용을 출력한다. 


![image](https://user-images.githubusercontent.com/71219602/170999011-d16b9c80-c3d3-4397-9428-9d0ad361e4b7.png)

### CODE
```C++
#include <iostream>
using namespace std;

int n;

// 거리 비용 배열
int dis[100001];

// 주유소 리터당 가격
int arr[100001];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
  
	cin >> n;
  
  // 10억 단위 정수 제약이 나왔을때는 long long 사용
	long long count = 0;
  
	for (int i = 0; i < n-1; i++)
	{
		cin >> dis[i]; // 거리 비용 입력받기
	}
	for (int j = 0; j < n; j++)
	{
		cin >> arr[j]; // 도시의 리터당 필요 금액 입력받기
	}

	long long min = arr[0]; // 최소 비용으로 첫 도시를 할당

	for (int k = 0; k < n-1; k++)
	{
		if (min >= arr[k]) // 만약에 리터당 가격이 제일 싸다면
		{
			min = arr[k]; // 최소값 설정
		}
		count += min * dis[k]; // 리터 * 거리 출력
	}
	cout << count << endl; // 가격 출력
	return 0;
}
```

### 후기

리터당 가격의 최소를 잡는다는 생각으로 최솟값을 갱신한다고 생각하면 금방 풀리는 문제였다.

다른 분의 풀이를 봤는데 나ㅗ아 비슷하게 푼것 같았다.


### 다른사람풀이

```C++
#include <iostream>
#include <cstdio>
#include <queue>
#include <algorithm>

using namespace std;

int dist[100000];
int cost[100000];

int main(void){
    int n;
    long long total=0;
    long long c_now;
    
    scanf("%d", &n);
    
    for(int i=1; i<n; i++){
        scanf("%d", &dist[i]);
    }
    for(int i=0; i<n; i++){
        scanf("%d", &cost[i]);
    }
    c_now = cost[0];
    total = c_now * dist[1]; // 첫이동은 그냥 따로 잡아줬나보다
    //첫번째->두번째 이동
    
    for(int i=1; i<n; i++){
        if(c_now < cost[i]){ // 최솟값이면 더해주고
            total += c_now * dist[i+1];
        }
        else{ // 아니라면 최솟값을 갱신해준다.
            c_now = cost[i];
            total += c_now*dist[i+1];
        }
    }
    printf("%lld\n", total); 
}
```
