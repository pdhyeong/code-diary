### 문제
다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 

다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.


예를 들어 S=0001100 일 때,

전체를 뒤집으면 1110011이 된다.

4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.

하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.

문자열 S가 주어졌을 때, 다솜이가 해야하는 행동의 최소 횟수를 출력하시오.

--------------------------

### 입력

첫째 줄에 문자열 S가 주어진다. S의 길이는 100만보다 작다.

--------------------------

### 출력

첫째 줄에 다솜이가 해야하는 행동의 최소 횟수를 출력한다.

---------------------------

### 예제 입력 1 

0001100

### 예제 출력 1 

1

### 예제 입력 2 

11111

### 예제 출력 2 

0

### 예제 입력 3 

00000001

### 예제 출력 3 

1

### 예제 입력 4 

11001100110011000001

### 예제 출력 4 

4

### 예제 입력 5 

11101101

### 예제 출력 5 

2

-------------------------------

### CODE

```C++

#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int main() {
    string s;
    cin >> s;
    
    char s1 = s[0];
    int result0 = 0; // 0이 나오는 횟수
    int result1 = 0; // 1이 나오는 횟수
    
    if(s1 == '1')
    {
        result1++; // 첫번째에 1이 나오면 1이 나오는 횟수 증가
    }
    else
        result0++;
    
    for(int i =1;i<s.size()-1;i++)
    {
        if(s[i] != s[i+1]){ // 숫자가 반전되는 경우
            if(s[i+1] == '1') // 그 반전되는 숫자가 1일 경우 0이 나오는 횟수증가
                result0 += 1;
            else // 아니라면 1이 나오는 횟수 증가
                result1 +=1;
        }
    }
    cout << min(result0,result1) << endl; // 둘중 더욱 작은 반전횟수를 출력
    return 0;
}
```
---------------------------------

### 후기

처음에는 문자열을 예를 들어 0001100 이 들어오면 숫자가 반전되는 구간에서 while문으로 문자가 다시 반전되면 count를 했는데

2중 반복문으로 마땅히 사용할만한 코드는 아니었던것 같아서 다른 사람의 코드르 보고 이렇게도 풀수있구나 해서 좀 많이 부족하다고 느꼈다.

푸는게 다가 아니라 효율적으로 만드는 연습도 해봐야겠다.
