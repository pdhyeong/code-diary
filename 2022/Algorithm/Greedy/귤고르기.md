### 문제 

경화는 과수원에서 귤을 수확했습니다.

경화는 수확한 귤 중 'k'개를 골라 상자 하나에 담아 판매하려고 합니다.

그런데 수확한 귤의 크기가 일정하지 않아 보기에 좋지 않다고 생각한 경화는 귤을 크기별로 분류했을 때 서로 다른 종류의 수를 최소화하고 싶습니다.

예를 들어, 경화가 수확한 귤 8개의 크기가 [1, 3, 2, 5, 4, 5, 2, 3] 이라고 합시다. 

경화가 귤 6개를 판매하고 싶다면, 크기가 1, 4인 귤을 제외한 여섯 개의 귤을 상자에 담으면,

귤의 크기의 종류가 2, 3, 5로 총 3가지가 되며 이때가 서로 다른 종류가 최소일 때입니다.

경화가 한 상자에 담으려는 귤의 개수 k와 귤의 크기를 담은 배열 tangerine이 매개변수로 주어집니다.

경화가 귤 k개를 고를 때 크기가 서로 다른 종류의 수의 최솟값을 return 하도록 solution 함수를 작성해주세요.

------------------------------------------------------------

### 제한사항

1 ≤ k ≤ tangerine의 길이 ≤ 100,000

1 ≤ tangerine의 원소 ≤ 10,000,000

### 입출력 예
```
k	tangerine	result
6	[1, 3, 2, 5, 4, 5, 2, 3]	3
4	[1, 3, 2, 5, 4, 5, 2, 3]	2
2	[1, 1, 1, 1, 2, 2, 2, 3]	1
```

------------------------------------------------------------

### 입출력 예 설명

입출력 예 #1

본문에서 설명한 예시입니다.
입출력 예 #2

경화는 크기가 2인 귤 2개와 3인 귤 2개 또는 2인 귤 2개와 5인 귤 2개 또는 3인 귤 2개와 5인 귤 2개로 귤을 판매할 수 있습니다.

이때의 크기 종류는 2가지로 이 값이 최소가 됩니다.

입출력 예 #3

경화는 크기가 1인 귤 2개를 판매하거나 2인 귤 2개를 판매할 수 있습니다.

이때의 크기 종류는 1가지로, 이 값이 최소가 됩니다.

------------------------------------------------------------

### Approach

사람마다 접근법은 다르겠지만 나는 이런 숫자대로 무게 관련 문제가 나오면 배열을 생성 한뒤

ex) arr[무게 초과제한] 안에 ++ 를하여 갯수를 넣는 방법을 사용한다.

해당 무게들을 모두 무게 해당하는 배열에 갯수만큼 넣은다음 무게를 기준으로

k개를 공급했을때 봉지를 1개를 소모하므로 그 배열안에 숫자를 k를 삭감한뒤에 봉지를 하나 추가해준다.

------------------------------------------------------------

### Code

```C++
#include <vector>
#include <algorithm>
using namespace std;

bool compare(int a,int b){
    return a > b;
}
int solution(int k, vector<int> tangerine)
{

  int ve[10000001]={};
  int i, answer=0, p=0;
  for(i=0; i<tangerine.size(); ++i)    
      ve[tangerine[i]]++;
  vector<int> result;
  for(i=1; i<=10000000; ++i)
      if(ve[i])
          result.push_back(ve[i]);
  sort(result.begin(), result.end(),compare);
  while(k>0)
  {
      k-=result[p++];
      answer++;
  }
 return answer;
}

```

------------------------------------------------------------

### 문제링크

https://school.programmers.co.kr/learn/courses/30/lessons/138476

주말에 블록체인 실습툴이 연동이 안되서 시간내서 풀어봤다..ㅎㅎ....간단한 그리디 문제라 중간에 오류만 없다면 킬링타임으로 풀기 

------------------------------------------------------------

### 다른 사람의 풀이

다른사람이 푼 풀이지만 경이로운게 있어서 봤다.

언어는 파이썬이지만 너무 간결해서 놀랐다.

```py
from collections import Counter

def solution(k, tangerine):
    answer = 0
    # [1] 자료 변환 
    count = sorted(Counter(tangerine).items(),reverse = True, key = lambda x : x[1])
    # [2] 최소 종류 계산
    for key, value in count:
        if k <= 0: break
        k -= value
        answer += 1
    return answer
```

