### 문제

n * m 크기의 금광이 잇습니다. 금광은 1 * 1 크기의 칸으로 나누어져 있으며, 

각 칸은 특정한 크기의 금이 들어 있습니다. 채굴자는 첫 번째 열부터 출발하여 금을 캐기 시작합니다.

맨 처음에는 첫 번째 열의 어느 행에서든 출발할 수 있습니다. 이후에 m 번에 걸쳐서 매번 오른쪽 위, 오른쪽 아래, 오른쪽 아래

3가지 중 하나의 위치로 이동 해야 합니다. 결과적으로 채굴자가 얻을 수 있는 금의 최대 크기를 출력하는 프로그램을 작성하세요.

```
1 3 3 2
2 1 4 1
0 6 4 7
```

가장 왼쪽 위의 위치를(1,1), 가장 오른쪽 아래의 위치를 (n,m)이라고 할 때, 위 예시에서는

(2,1) -> (3,2)-> (3,3)-> (3,4)의 위치로 이동하면 총 19만큼의 금을 채굴할 수 있으며, 이때의 값이 최댓값입니다.

-----------------------------------------------

### 입력조건

* 첫째 줄에 테스트 케이스 T가 입력됩니다. (1 <= T <= 1000)

* 매 테스트 케이스 첫째 줄에 n과 m이 공백으로 구분되어 입력됩니다.(1 <= n,m <= 20) 둘째줄에
n * m개의 위치에 매장된 금의 개수가 공백으로 구분되어 입력됩니다. (0 <= 각 위치에 매장된 금의 개수 <= 100)

--------------------------------------------------

### 출력 조건
* 테스트 케이스마다 채굴자가 얻을 수 있는 금의 최대 크기를 출력합니다. 각 테스트 케이스는 줄 바꿈을 이용해 구분합니다.

-----------------------------------------------

### 입력 예시

```
2
3  4
1  3  3  2  2  1  4  1  0  6  4  7
4  4
1  3  1  5  2  2  4  1  5  0  2  3  0  6  1  2
```

### 출력 예시

19
16

--------------------------------------------

### 처음 나의 생각

처음 문제를 잘못이해해서 1행 1열에서만 시작하는줄알고 arr[i-1][j] , arr[i][j-1], arr[i-1][j-1] 셋을 점화식으로 사용했는데

사실상 첫번째 열에서 아무렇게나 출발하면 되는 문제여서 시간을 날렸다....

-------------------------------------------

### CODE

```C++
#include <bits/stdc++.h>

using namespace std;

int t, n, m;
int arr[20][20];
int dp[20][20];

int main(void) {
    cin >> t;
    for (int tc = 0; tc < testCase; tc++) {
        // 금광 정보 입력
        cin >> n >> m;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                cin >> arr[i][j];
            }
        }
        // 배열 복사
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                dp[i][j] = arr[i][j];
            }
        }
        for (int j = 1; j < m; j++) {
            for (int i = 0; i < n; i++) {
                int leftUp, leftDown, left;
                // 왼쪽 위에서 오는 경우
                if (i == 0) // 예외 값
                    leftUp = 0;
                else 
                    leftUp = dp[i - 1][j - 1];
                // 왼쪽 아래에서 오는 경우
                if (i == n - 1) // 예외 값 
                    leftDown = 0;
                else 
                    leftDown = dp[i + 1][j - 1];
                // 왼쪽에서 오는 경우
                left = dp[i][j - 1];
                dp[i][j] = dp[i][j] + max(leftUp, max(leftDown, left)); // 점화식 적용
            }
        }
        int result = 0;
        for (int i = 0; i < n; i++) {
            result = max(result, dp[i][m - 1]); // 오른쪽 열값중에 가장 큰 값
        }
        cout << result << '\n'; // 
    }
}
```

-----------------------------------------

### 후기

다이나믹 프로그래밍도 풀다보니까 뭔가 조금씩 감이 찾아지는 느낌이다.
ㅎ 기분이 좋다. 다른문제도 좀 풀어봐야겠다.
