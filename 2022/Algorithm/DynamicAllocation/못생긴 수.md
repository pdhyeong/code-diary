### 문제

못생긴 수란 오직 2,3,5만을 소인수로 가지는 수를 의미합니다. 다시 마해 오직 2,3,5를 약수로 가지는 합성수를 의미합니다. 1은 못생긴 수 라고 가정합니다.

따라서 못생긴 수들은 {1,2,3,4,5,6,8,9,10,12,15....} 순으로 이어지게 됩니다. 이때 n번째 못생긴 수를 찾는 프로그램을 작성하세요.


-------------------------------------------------------

### 입력조건 

* 첫째 줄에 n이 입력됩니다. (1<= n <= 1000)

### 출력조건

* n번째 못생긴수를 출력합니다.


---------------------------------------------------

### 처음나의 생각

문제 분류는 다이나믹프로그래밍으로 분류 되어 있어서 의외였다.

입력 데이터 값이 1000이기에 그냥 아래 코드와 같이 어떠한 배열에 1000까지의 약수들만 넣으면 금방 풀릴거 라고 생각하였다.

```C++
int main(int argc, const char * argv[]) {
    int n;
    cin >> n ;
    vector<int> v;
    int count = 1;
    
    v.push_back(1);
    
    for(int i = 1;i<1000;i++)
    {
    // 2의 약수거나 3의 약수거나 5의 약수면
        if(i % 2 == 0 || i % 3 == 0 || i % 5==0){
            v.push_back(i);
        }
    }
    cout << v[n-1] << endl;
    return 0;
}
```

시간 복잡도로 봐도 크게 시간초과나 오류가 나진 않을 것 같았지만 동적프로그래밍으로 푸는 답을 보고 좀 놀랐다.

--------------------------------------------------------

### CODE

```C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int dp[1001] = { 0,};

int main(int argc, const char * argv[]) {
    int n;
    cin >> n ;
    
    // 2의 배수 3의 배수 5의 배수를 위한 갯수
    int i2 =0,i3 =0,i5 = 0;
  
    int next2 = 2,next3 = 3,next5 = 5;
    
    dp[0] = 1;
    
    for(int i = 1;i<n;i++)
    {
        // next2,next3,next5를 갱신 하면서 가장 작은 값을 넣기
        dp[i] = min({next2,next3,next5});
        
        // 2의 등장횟수 +1 하고 등장횟수 * 2 를 dp[i]에 넣는다.
        if(dp[i] == next2)
        {
            i2 += 1;
            //next2를 2를 곱한수로 갱신 시켜 배열의 다음 인덱스의 삽입할 비교대상으로 만든다.
            next2 = dp[i2] * 2;
        }
        // 위와 동일
        if(dp[i] == next3)
        {
            i3 += 1;
            next3 = dp[i3] * 3;
        }
        if(dp[i] == next5)
        {
            i5 += 1;
            next5 = dp[i5] * 5;
        }
    }
    cout << dp[n-1] << endl;
    return 0;
}
```

--------------------------------------------

### 후기

진짜 이 문제를 동적프로그래밍으로 풀려는 생각조차 못했다.

저 문제를 보고 i2,i3,i5을 선언하여 갯수를 올리면서 저렇게 3개의 곱의 변수를 갱신 시키면서 최소값을 배열안에 넣고 푸는 방식을 생각한다는거 자체가 놀랍다.

알고리즘을 잘푸는 사람들 뇌가 궁금해지는 하루 였다. 진짜 ㅇㅇ.....

