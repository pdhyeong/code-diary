### 이코테 효율적인 화폐 구성

### 문제

N가지 종류의 화폐가 있다.

이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 한다.

이때 각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다.

예를들어 2원, 3원 단위의 화폐가 있을 떄는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐개수이다.

### 입력조건

* 첫째 줄에 N,M이 주어진다. (1<= N <= 100, 1 <= M <= 10,000)
* 이후 N개의 줄에는  각 화폐의 가치가 주어진다. 화폐 가치는 10,000보다 작거나 같은 자연수이다.

### 출력조건
* 첫째 줄에 M원을 만들기 위한 최소한의 화폐 개수를 출력한다.
* 불가능할 때는 -1을 출력한다.

### 입력 예시
2    15

2

3ㅇ

### 출력예시

5

### 입력예시 2

3    4

3

5

7

### 출력예시2

-1


### CODE
```C++
#include<iostream>
#include <vector>

using namespace std;

int main(void) {
    int n, m;
    vector<int> arr;
    cin >> n >> m;

    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        arr.push_back(x);
    }
    vector<int> d(m + 1, 10001);
    
    
    d[0] = 0;
    for (int i = 0; i < n; i++) {
        for (int j = arr[i]; j <= m; j++) {
            // (i - k)원을 만드는 방법이 존재하는 경우
            if (d[j - arr[i]] != 10001) { // 값이 존재하지 않을때는 100001이 나온다. 값이 존재 하는 것중에 계산하는것
                d[j] = min(d[j], d[j - arr[i]] + 1); // 점화식으로 바꿨을때 a = min(a i, a i-k + 1)이 나온다. 
            }
        }
    }

    // 계산된 결과 출력
    if (d[m] == 10001) { // 최종적으로 M원을 만드는 방법이 없는 경우
        cout << -1 << '\n';
    }
    else {
        cout << d[m] << '\n';
    }
}
```
### 후기

하 ...... 진짜 dp랑 안맞는거 같다 혼자 5시간은 고민했는데도 엉뚱한 점화식으로 바꿔서 말도 안되는 답이 나오지 않나... 결국 화나서 강의영상봤다.

저 점화식으로 바꾸는 생각 자체를 어떻게 해야되는지 모르겠다. 그냥 다음주나 종만북에서 dp 관련 자료들이나 메모제이션 기법 영상을 제대로 봐바야겠다.
