### 문제

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

위 그림은 크기가 5인 정수 삼각형의 한 모습이다.

맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때,

이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라.

아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.

삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.

-------------------------------------------

### 입력

첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.

---------------------------------------

### 출력

첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.

----------------------------------------

### 예제 입력 1 
```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

### 예제 출력 1 

30

---------------------------------------

### 처음 생각한 풀이

문제가 위에서 부터 아래로 내려오면서 배열 arr안에 값을 넣는다고 생각하면 값을 arr안에 입력하고

새로운 배열을 만들어서 arr의 값이 왼쪽아래과 아래로 밖에 안내려오므로 둘의 최댓값을 비교하면서 값을 갱신하면 될 것이라고 생각했다.

-----------------------------------

### CODE

```C++
#include <iostream>
#include<algorithm>

using namespace std;

int hr[501][501] = { 0 , };
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j <= i; j++)
		{
			int k;
			cin >> k;
			hr[i][j] = k;
		}
	}
  // 배열 값 갱신
	for (int i = 1; i < n; i++)
	{
		for (int j = 0; j <= i; j++)
		{
			hr[i][j] = hr[i][j] + max(hr[i - 1][j - 1], hr[i-1][j]); // 바로위hr[i][j-1]와 왼쪽위 hr[i-1][j-1]의 최댓값을 대입
		}
	}
	int result = 0;
	for (int i = 0; i < n; i++)
	{
		result = max(result, hr[n - 1][i]); // 마지막 열의 최댓값 출력
	}
	cout << result << endl;
	return 0;
}
```

-----------------------------------------

### 후기

arr이라는 배열과 dp라는 배열을 따로 사용해서 값을 분리하려고 했는데

전에 배열들을 검사하는 것이라 현재의 위치의 배열에서는 최댓값들이 삽입된 dp 배열처럼 갱신 되기때문에

배열을 하나만 사용해서 메모리 사용량을 줄일 수 있다는 피드백을 받고 고쳤다. 좀 충격이었다.... 왜 이생각을 못했지

