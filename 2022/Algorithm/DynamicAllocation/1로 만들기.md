## 이코테 1로 만들기

## 문제 

정수 X가 주어질 때 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지 이다.

1.X가 5로 나누어떨어지면 5로 나눈다.

2. X가 3으로 나누어떨어지면, 3으로 나눈다.

3. X가 2로 나누어떨어지면 ,2로 나눈다.

4. X에서 1을 뺀다.

정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 1을 만들려고한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

예를 들어, 정수가 26이면 다음과 같이 계산해서 3번씩 연산이 최솟값이다.

1. 26 - 1 = 25

2. 25 / 5 = 5

3. 5 / 5 = 1

### 입력 조건

첫째 줄에 정수 X가 주어진다.(1 <= X <= 30,000)

### 출력조건 

첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

### 입력예시

25

### 출력예시

3


### CODE

```C++
#include <iostream>
#include <algorithm>

using namespace std;

int d[30001] = {0,}; // 값을 저장해갈 배열
int main(int argc, const char * argv[]) {
    int n;
    cin >> n;
    for (int i=2;i<=n;i++)
    {
        d[i] = d[i-1] + 1; // -1 씩 했을때 연산횟수
        if(i%2==0 && d[i] > d[i / 2]+1) // 2로 나누어떨어졌을때 2로 나누어떨어진 값보다 1번의 연산을 더한다.
        {
            d[i] = d[i/2] +1;
        }
        if (i % 3 == 0 && d[i] > d[i / 3]+ 1) // 3으로 나누어떨어졌을때 3으로 나누어떨어진 값보다 1번의 연산을 더한것.
        {
            d[i] = d[i / 3] +1;
        }
        if( i % 5 ==0 && d[i] > d[i / 5] + 1) // 5로 나누어 떨어졌을때 5로 나누어떨어진 값보다 1번의 연산을 더한다. 
        {
            d[i] = d[i / 5] + 1; // 그 값을 d[i] 값을 넣는다.
        }
    }
    cout << d[n] << endl;
    return 0;
}
```

## 백준 12852

### 문제

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

X가 3으로 나누어 떨어지면, 3으로 나눈다.

X가 2로 나누어 떨어지면, 2로 나눈다.

1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

### 입력

첫째 줄에 1보다 크거나 같고, 10^6보다 작거나 같은 자연수 N이 주어진다.

### 출력

첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

둘째 줄에는 N을 1로 만드는 방법에 포함되어 있는 수를 공백으로 구분해서 순서대로 출력한다. 정답이 여러 가지인 경우에는 아무거나 출력한다.

<img width="1173" alt="스크린샷 2022-05-23 오후 7 08 19" src="https://user-images.githubusercontent.com/71219602/169796582-ad5c80ad-ec78-42c9-8fdd-271ce2d0f56e.png">


### CODE

```C++
#include <iostream>
#include <algorithm>

using namespace std;

int d[1000001]; //  바텀-탑 방식으로 연산 횟수를 넣을 배열
int before[1000001]; // 연산 되고난 후에 값을 넣을 배열 
int main(int argc, const char * argv[]) {
    int n;
    cin >> n;
    d[1] = 0;
    before[1] = -1;
    for (int i=2;i<n+1;i++)
    {
        d[i] = d[i-1] + 1;
        before[i] = i - 1;
        if(i%2==0 && d[i] > d[i /2]+1)
        {
            d[i] = d[i/2]+1;
            before[i] = i / 2; // before[i]에는 그냥 i / 2 의 값이 담긴다. ex) before[10] = 10 / 2 = 5 즉 연산 후에 값을 넣는 배열
        }
        if (i % 3 == 0 && d[i] > d[i / 3] + 1) // 3으로 나누어 떨어질때
        {
            d[i] = d[i / 3] + 1;
            before[i] = i / 3; 
        }
    }
    cout << d[n] << endl; // d[n]에 들어가있는 연산 횟수 값 출력
    while (n != -1) // 즉 before이 -1이 이므로 1이 나올떄 까지 반복
    {
        cout << n <<" ";
        n = before[n]; // 연산후에 연산후에 값이 들어있는 배열안에 값을 출력 후 연산값을 사용해다시 before안에 연산값을 가져온다.
    }
    cout << endl;
    return 0;
}

```


### 후기

솔직히 ㅋㅋㅋ 문제만 보고는 ? 하면서 못풀었다. 근데 전에 봤던 바텀 업 방식이 생각나서 끄적이다가 옆에서 친구가 알려줘서 푼것같다.

바텀 - 탑 방식으로 풀었지만 진짜 이론 설명없이 그냥 풀라고했으면 멍만 때렸을거 같다. 그래서 이와 같이 비슷한 문제가 백준에 있길래 가져와서 풀었다.

정말 생각하는 거 지만 나는 정말 dp에 정말 약한거 같다. 공부좀 빡세게 해야겠다. 종만북에 dp 알고리즘에 대한 고찰 부분이 있다는 보면서 공부좀 해야겠다.
