## 문제

호진이는 빨간색 방울과 초록색 방울로 구성된 트리 장식을 가지고 있습니다.

이 방울들은 한 줄로 연결되어 있는데, 호진이는 이중 일부를 잘라 트리를 장식하려 합니다.

호진이는 균형을 좋아해서, 장식에 사용하는 빨간색 방울과 초록색 방울의 개수를 동일하게 사용하려 합니다.

호진이는 장식의 길이를 가장 길게 잘라 트리를 꾸미려고 합니다.

1은 빨간색 방울 2는 초록색 방울이라고 가정하면 

[1, 2, 1, 1, 1, 2, 2, 1]

예를 들어, 위의 배열에서 첫 번째 방울과 두 번째 방울 사이를 자르고, 일곱 번째 방울과 여덟 번째 방울 사이를 자르면 (초록색, 빨간색, 빨간색, 빨간색, 초록색, 초록색)으로,

길이가 6인 장식을 얻을 수 있습니다.

방울의 색을 담은 배열 bell이 매개변수로 주어집니다.

빨간색 방울과 초록색 방울의 개수가 같게 자른 장식 길이의 최댓값을 return 하도록 solution 함수를 작성해주세요.

------------------------------------------------------------

### 제한사항

1 ≤ bell의 길이 ≤ 1,000,000

1 ≤ bell[i] ≤ 2

bell[i] = 1은 빨간색 장식을, bell[i] = 2는 초록색 장식을 의미합니다.

------------------------------------------------------------

### 입출력 예

```
bell	result
[1, 2, 1, 1, 1, 2, 2, 1]	6
[1, 1, 1, 1, 1, 1]	0
[2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1]	4
```

------------------------------------------------------------

### 입출력 예 설명

입출력 예 #1

본문에서 설명한 예시입니다.

입출력 예 #2

빨간색 방울과 초록색 방울의 수가 같도록 장식을 자를 수 없습니다.

입출력 예 #3

첫 번째부터 네 번째 방울을 사용하면, 빨간색 방울과 초록색 방울의 수가 같도록 트리를 장식할 수 있으며, 이때 길이가 최댓값이 됩니다.


### Approach

처음에 스택을 사용하는 문제라고 생각해서 스택으로 접근하려 했지만 생각보다 쉽지 않았다

먼저 방울의 비율이 맞는 경우중 길이가 가장 긴것을 고르는 문제이기 때문에

먼저 비율을 맞추기 위해 빨간색은 -1 초록색은 1로 치환한다.

그렇게 나온 배열의 누적합을 더하면 해당 초록색과 빨간색의 등장 횟수의 비례하는 결과 값이 나오는데

그 결과값 중에서 어떠한 인덱스에 대해 나오는 숫자중에 길이를 시작점과 끝 지점을 투 포인터로 잡아서 결과값이 최대인 것을 반환한다.

------------------------------------------------------------

### CODE

```py
from itertools import accumulate

def solution(bell):
    coors_start = {}
    coors_end = {}
    for i, x in enumerate(accumulate([0] + [-1 if b == 1 else 1 for b in bell])):
        if x not in coors_start:
            coors_start[x] = i
        coors_end[x] = i
    return max(coors_end[x] - coors_start[x] for x in coors_end)
```

------------------------------------------------------------

### 후기

ㅋㅋㅋ 말이 쉽지 내 생각대로 구현하니까 시간초과가 떠서 결국에 효율적인 해결의 답지를 보게 되었다.

```py
def solution(bell):
    answer = 0
    bells = [0]
    
    for i in range(len(bell)):
        if bell[i] == 1:
            bells.append(-1)
        else :
            bells.append(1)
            
    for i in range(1,len(bells)):
        bells[i] = bells[i-1] + bells[i]
        
        
    for i in range(len(bells)):
        count = 0
        startpoint = 0
        endpoint = 0
        for j in range(len(bells)):
            if count == 0 and bells[i] == bells[j]:
                startpoint = j
                count += 1
            elif bells[i] == bells[j]:
                endpoint = j
            answer = max(endpoint-startpoint,answer)
    return answer
```

위와 같이 내 생각을 그대로 코드로 적어서 했는데 아무래도 n^2의 시간 복잡도가 필요하다보니까 결과 값은 맞는데

시간이 초과되어서 풀지 못했다.

python에 익숙하지 않아서 여러 매서드들을 찾아봐야겠다.
