### 이코테 음료수 얼려먹기
------------------------
### 문제

N*M 크기의 얼음 틀이 있다. 구멍이 뚫려 있는 부분은 0 칸막이가 존재하는 부분은 1로 표시된다. 구멍이 뚫려 있는 부분끼리 상,하,좌,우로

붙어 있는 경우 서로 연결되어 있는 것으로 간주한다. 이때 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하시오.

다음의 4*5 얼음 틀 예시에서는 아이스크림이 총 3개 생성된다.


<img width="760" alt="스크린샷 2022-05-20 오후 7 24 31" src="https://user-images.githubusercontent.com/71219602/169508675-84a21826-20a2-45c8-8466-0858a71ee31c.png">

<br>

### 입력조건

----------------------

* 첫 번째 줄에 얼음 틀의 세로 길이 N과 가로 길이 M이 주어진다. (1 <= N, M >= 1000)
* 두 번째 줄부터 N+1 번째 줄까지 얼음 틀의 형태가 주어진다.
* 이때 구멍이 뚫려있는 부부은 0, 그렇지 않은 부분은 1이다.

<br>

### 출력조건

--------------------------------

* 한 번에 만들 수 있는 아이스크림의 개수를 출력한다.

<br>


### CODE

-------------------------------

```C++
#include<iostream>
using namespace std;

int n, m;
int graph[1000][1000];

// DFS로 특정 노드를 방문하고 연결된 모든 노드들도 방문
bool dfs(int x, int y) {
    // 주어진 범위를 벗어나는 경우에는 즉시 종료
    if (x <= -1 || x >=n || y <= -1 || y >= m) {
        return false;
    }
    // 현재 노드를 아직 방문하지 않았다면
    if (graph[x][y] == 0) {
        // 해당 노드 방문 처리
        graph[x][y] = 1;
        // 상, 하, 좌, 우의 위치들도 모두 재귀적으로 호출
        for(int i=0;i<4;i++)
        {
            int nx = x + dx[i];
            int ny = y + dy[i];
            dfs(nx,ny);
        }
        return true;
    }
    return false;
}

int main() {
    // N, M을 공백을 기준으로 구분하여 입력 받기
    cin >> n >> m;
    // 2차원 리스트의 맵 정보 입력 받기
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            scanf("%1d", &graph[i][j]);
        }
    }
    // 모든 노드(위치)에 대하여 음료수 채우기
    int result = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            // 현재 위치에서 DFS 수행
            if (dfs(i, j)) {
                result += 1;
            }
        }
    }
    cout << result << '\n'; // 정답 출력 
}
```
--------------------------------
### 후기

흔히 좌표를 이용하는 DFS문제로 생각보다 쉽게 해결 할 수 있었다. 0으로 상하좌우를 탐색하여 연속탐색이 될경우 +1 을하고

벽에 막히면 false를 반환하여 다른 구역을 탐색하는 매커니즘을 익혀두니 관련 문제가 나왔을때 날먹이 가능한것같다. 

단 , dfs함수의 반환값과 어떻게 활용할 것인지는 생각하면서 조금씩 응용해봐야하는 것 같다.
